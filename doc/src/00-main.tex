\documentclass[openany, 12pt]{book}
\input{preamble}
\title{Hakyll}
\author{Idris}
\date{November 2024}

\input{glossary}
\makeglossaries
\begin{document}
% \maketitle{}

\tableofcontents

\chapter{Major Types}
\begin{definition}{Monad}{}
  \begin{multicols}{2}
    \begin{enumerate}[label = {(\arabic*)}]
      \item Compiler
      \item Rules
    \end{enumerate}
  \end{multicols}
\end{definition}

\begin{definition}{Rules\index{rule}}{}
  Each \hask{Rule} normally consists of three parts:

  \begin{enumerate}[label = {(\arabic*)}]
    \item Starting files $S$.  $s \in S$ are the files that will then make up the
          static site. This includes all the normal web stuff like html, css,
          svg, etc, but then also stuff that needs to be transformed like
          markdown. $s\in S$ is identified via a pattern $P$.
    \item ending file $T$, which now in the domain of websites and routing,
          so now it is called a route.
    \item file transformation, which is a function $f: S \rightarrow T$
          which takes
  \end{enumerate}

  \begin{enumerate}[label = {(\arabic*)}]
    \item Source files (like Markdown files) to process, collected with e.g.
          \hask{match} or \hask{create}.
    \item Compilation steps (like Markdown to HTML) to transform files'
          content to some output content (steps are collected within Compiler
          and executed with compile).
    \item Routing to determine if and where an output content will be
          written out. For a static site this determines under which URL the
          output content will be available (configured with route and
          Routes).
  \end{enumerate}
\end{definition}

\begin{definition}{Compiler\index{Compiler}}{}
  It defines the fundamental Compiler type and primitive Compilers as well as
  several variants on load, which allow you to bring together multiple
  resources to create a single output.
\end{definition}

\begin{definition}{Monoid}{}
  \begin{multicols}{2}
    \begin{enumerate}[label = {(\arabic*)}]
      \item Routes
      \item Context
    \end{enumerate}
  \end{multicols}
\end{definition}

\begin{definition}{Context\index{Context}}{}
  You can’t do much with a Template if you don’t have a Context: this module
  provides some predefined Contexts and the tools to build your own.
\end{definition}

\begin{definition}{Routes\index{route}}{}
  Part of the \hask{Rules} processing pipeline. Specify where compiled items
  should go in the output site---used for determining the output file. For
  example, you probably want to write the processed contents of
  \bash{contact.markdown} to \bash{_site/contact.html} and not
  \bash{_site/contact.markdown}.
\end{definition}

\chapter{CLI}
\begin{table}[h]
  \centering
  \begin{tabular}{ll}
    \toprule
    \textbf{Command}  & \textbf{Description}                              \\
    \midrule
    build             & Generate the site                                 \\
    check             & Validate the site output                          \\
    clean             & Clean up and remove cache                         \\
    deploy            & Upload/deploy your site                           \\
    preview           & use the \texttt{watch} command                    \\
    rebuild           & Clean and build again                             \\
    server            & Start a preview server                            \\
    watch             & Autocompile on changes and start a preview server \\
    watch --no-server & watch and recompile without running a server      \\
    \bottomrule
  \end{tabular}
  \caption{Command reference for site management}
\end{table}

\begin{table}[h]
  \centering
  \begin{center}
    \begin{tabular}{ll}
      \toprule
      directory & description                                       \\
      \midrule
      posts     & Source markdown or org files for blog entries     \\
      templates & HTML or Hakyll templates used to render pages     \\
      \_cache   & Build cache for incremental compilation           \\
      \_site    & Generated static site output ready for deployment \\
      \bottomrule
    \end{tabular}
  \end{center}
  \caption{Common directories in hakyll projects}
\end{table}

\chapter{Conceptual}
\begin{intuition}{Hakyll}{}
  It's all about taking a directory $D_1$ and its files, and then
  transforming them to another directory $D_2$ plus rules $R$ about how to
  route web requests so that they line up with the static web site in $D_2$.
\end{intuition}

\begin{definition}{Main}{}
  The main hakyll function that runs the whole show. There is also a hakyllWith
  function which allows for a custom configuration.
\end{definition}

\begin{definition} {Identifier.Pattern}{}
  Combinators for creating patterns, ie predicates that pick out a set of
  resources:
  \begin{multicols}{2}
    \begin{enumerate}[label = {(\arabic*)}]
      \item filesystem globs
      \item explicit lists
      \item regular expressions
      \item etc
    \end{enumerate}
  \end{multicols}
\end{definition}

\begin{definition}{match}{}
  Group the rules via \hask{match}. The filter on what match is done via
  \hask{Pattern}.
  \begin{haskell}{}
match  :: Pattern      -> Rules() -> Rules ()
create :: [Identifier] -> Rules() -> Rules ()
	\end{haskell}
\end{definition}

\begin{definition}{Configuration}{}
  Basically this tells you all the details about the filesystem options and
  network options for the site.

  \begin{haskell}{}
-- | Default configuration for a hakyll application
defaultConfiguration :: Configuration
defaultConfiguration = Configuration
    { destinationDirectory = "_site"
        , storeDirectory       = "_cache"
        , tmpDirectory         = "_cache/tmp"
        , providerDirectory    = "."
        , ignoreFile           = ignoreFile'
        , deployCommand        = "echo 'No deploy command specified' && exit 1"
        , deploySite           = system . deployCommand
        , inMemoryCache        = True
        , previewHost          = "127.0.0.1"
        , previewPort          = 8000
    }
where
    ignoreFile' path
    | "."    `isPrefixOf` fileName = True
    | "#"    `isPrefixOf` fileName = True
    | "~"    `isSuffixOf` fileName = True
    | ".swp" `isSuffixOf` fileName = True
    | otherwise                    = False
where fileName = takeFileName path
	\end{haskell}
\end{definition}

\printindex{}
\glsaddallunused
\printglossaries
\end{document}
