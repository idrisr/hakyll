<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>My Hakyll Blog - Debugging a Debugger</title>
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">My Hakyll Blog</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Debugging a Debugger</h1>
            <article>
    <section class="header">
        Posted on October 12, 2015
        
    </section>
    <section>
        <p><a href="http://lldb.llvm.org/">LLDB</a> is the debugger that ships automatically with
XCode. Everyhing you can do with LLDB is also available through a Python API so
you can write python code to programmatically debug anything that you write
using XCode, including C, Objective-C, Swift, and C++.</p>
<p>It’s a really powerful way to debug as you can automate much of the debugging
process and do things that aren’t practical without scripting.</p>
<p>With this power comes a downside - you’re now writing code to debug code. What
if your debugging code has a bug? Into the abyss we go…</p>
<p>The Facebook dev team has created the
<a href="https://github.com/facebook/chisel">chisel</a> library which bundles tools to
solve common debugging tasks. Chisel can be installed as a single python package
with <a href="http://brew.sh/">homebrew</a> like <code>brew install chisel</code>.</p>
<p>Chisel offers a LLDB function called <code>wivar</code> which sets the watchpoint on an
object’s instance variable like so <code>wivar self _number</code>. This same functionality
is offered by XCode’s debug GUI, so I’d expect that either method would create
the a watchpoint watching the same memory address.</p>
<p>___ ## El Bug de Debug</p>
<p>As you can see from the gif below, the XCode gui and the <code>wivar self _number</code>
cause different results. If the commands were both equivalent, which they should
be, they’d show the same memory address in the <code>new value</code> field. There was an
existing github issue on this bug so I had assurance it wasn’t just me so I
decided to dig in.</p>
<figure>
<img src="http://i.giphy.com/xTiTnz7bNkagGeCGg8.gif" alt="cat gif" />
<figcaption aria-hidden="true">cat gif</figcaption>
</figure>
<p>— ## LLDB with Python, quickly</p>
<p>First a very quick overview on how to add custom LLDB commands. LLDB allows you
to create your own custom debug commands with any script that calls into the
LLDB API, though currently only Python is supported. For example you create a
python module with the following functions:</p>
<p>{% highlight py linenos=table %} #!/usr/bin/env python # filename:
my_lldb_module.py</p>
<p>def hello_command(debugger, command, result, internal_dict): ““” This command
provides a greeting ““” print “Hello Command”</p>
<p>def __lldb_init_module(debugger, internal_dict): debugger.HandleCommand(‘command
script add -f my_lldb_module.hello_command hello’) {% endhighlight %}</p>
<p>and then you can load the command into an lldb session like so:</p>
<p>{% highlight sh linenos=table %} $ lldb (lldb) command script list For more
information on any command, type ‘help <command-name>’. (lldb) command script
import my_lldb_module.py (lldb) command script list Current user-defined
commands:</p>
<p>hello – For more information run ‘help hello’</p>
<p>For more information on any command, type ‘help <command-name>’. (lldb) help
hello This command provides a greeting</p>
<p>Syntax: hello (lldb) hello Hello Command (lldb) {% endhighlight %}</p>
<p>— ## Chisel and <code>wivar</code></p>
<p>The <code>chisel</code> library is effectively doing this for a few dozen commands, one of
which is the <code>wivar</code> command.</p>
<p>The meat of the command is the following:</p>
<p>{% highlight py linenos=table %} def run(self, arguments, options):
commandForObject, ivarName = arguments</p>
<pre><code>    objectAddress = int(fb.evaluateObjectExpression(commandForObject), 0)

    ivarOffsetCommand =
    '(ptrdiff_t)ivar_getOffset((void*)object_getInstanceVariable((id){},
    &quot;{}&quot;, 0))'.format(objectAddress, ivarName) ivarOffset =
    fb.evaluateIntegerExpression(ivarOffsetCommand)

    # A multi-statement command allows for variables scoped to the command,
    not permanent in the session like $variables. ivarSizeCommand =
    ('unsigned int size = 0;' 'char *typeEncoding = (char
    *)ivar_getTypeEncoding((void*)class_getInstanceVariable((Class)object_getClass((id){}),
    &quot;{}&quot;));' '(char *)NSGetSizeAndAlignment(typeEncoding, &amp;size, 0);'
    'size').format(objectAddress, ivarName) ivarSize =
    int(fb.evaluateExpression(ivarSizeCommand), 0)

    error = lldb.SBError() watchpoint =
    lldb.debugger.GetSelectedTarget().WatchAddress(objectAddress +
    ivarOffset, ivarSize, False, True, error)

    if error.Success(): print 'Remember to delete the watchpoint using:
    watchpoint delete {}'.format(watchpoint.GetID()) else: print 'Could not
    create the watchpoint: {}'.format(error.GetCString()) {% endhighlight sh
    %}</code></pre>
<p>Essentially what this function does is threefold:</p>
<ol type="1">
<li>find the memory address of the object</li>
<li>find the difference in bytes between the address of the object and the
<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/#//apple_ref/c/tdef/Ivar"><code>Ivar</code></a>,
a C struct, that contains our instance variable</li>
<li>determine the type encoding of the instance variable to get its memory size</li>
</ol>
<p>To undestand what’s going on here you have to parse those objective-c commands
that are being invoked, which is a segue to start understanding the objective-c
runtime.</p>
<p>— ## Fun with the Objective-C runtime</p>
<p>It took me a while to understand what was happening here, including reading the
<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html">Objective-C runtime
guide</a>,
(ps - if you’re writing Obj-C, do yourself a favor and read it).</p>
<p>— ### 1. Get the address of the object {% highlight py %} objectAddress =
int(fb.evaluateObjectExpression(commandForObject), 0) {% endhighlight %}</p>
<p>which ultimately resolves to create this objective-c command {% highlight objc
%} (id)(0x00007f8663633380) {% endhighlight %}</p>
<p>where <code>0x00007f8663633380</code> is the address determined in the previous step.</p>
<p>You can use lldb to show that this address be accessed multiple ways, including
using the name of the instance, and different forms of the numerical address of
the memory location:</p>
<p>{% highlight objc linenos=table %} (lldb) p (id)(self) (ViewController <em>) $1 =
0x00007f8663633380 (lldb) p self (ViewController </em>) $2 = 0x00007f8663633380
(lldb) p/t self (ViewController <em>) $3 =
0b0000000000000000011111111000011001100011011000110011001110000000 (lldb) p/o
self (ViewController </em>) $4 = 03770314330631600 (lldb) p/d self (ViewController
<em>) $5 = 140215169790848 (lldb) p/x self (ViewController </em>) $6 =
0x00007f8663633380 (lldb) po
0b0000000000000000011111111000011001100011011000110011001110000000
&lt;ViewController: 0x7f8663633380&gt;</p>
<p>(lldb) po 03770314330631600 &lt;ViewController: 0x7f8663633380&gt;</p>
<p>(lldb) po 140215169790848 &lt;ViewController: 0x7f8663633380&gt;</p>
<p>(lldb) po 0x00007f8663633380 &lt;ViewController: 0x7f8663633380&gt;</p>
<p>(lldb) {% endhighlight %}</p>
<p>— ### 2. Get the memory offset of the <code>Ivar</code></p>
<p>{% highlight py linenos=table %} ivarOffsetCommand =
’(ptrdiff_t)ivar_getOffset((void*)object_getInstanceVariable((id){}, “{}”,
0))’.format(objectAddress, ivarName) ivarOffset =
fb.evaluateIntegerExpression(ivarOffsetCommand) {% endhighlight %}</p>
<p>This command is a bit more involved so I’m going to unpack it to its simpler
parts. After this command is formatted with its string substituations it looks
like this objective-c command:</p>
<p>{% highlight objc linenos=table %}
(int)((ptrdiff_t)ivar_getOffset((void*)object_getInstanceVariable((id)140215169790848,
“_number”, 0)))</p>
<h1 id="cast-the-memory-address-to-be-an-object-id140215169790848">cast the memory address to be an object (id)140215169790848</h1>
<h1 id="get-the-value-of-the-instance-variable-_number">get the value of the instance variable <code>_number</code></h1>
<p>object_getInstanceVariable((id)140215169790848, “_number”, 0)</p>
<h1 id="cast-the-return-value-to-be-any-generic-pointer.-note-this-is-a-c-call-not">cast the return value to be any generic pointer. Note this is a C call, not</h1>
<p>Obj-C (void *)object_getInstanceVariable((id)140215169790848, “_number”, 0)</p>
<h1 id="get-the-offset-in-bytes-of-the-ivar-opaque-type-from-its-objects-starting">Get the offset in bytes of the Ivar opaque type from its object’s starting</h1>
<p>address ivar_getOffset((void *)object_getInstanceVariable((id)140215169790848,
“_number”, 0))</p>
<h1 id="cast-the-difference-in-bytes-to-a-ptrdiff_t.-not-strictly-necessary-but">Cast the difference in bytes to a ptrdiff_t. not strictly necessary, but</h1>
<p>doesn’t hurt
(ptrdiff_t)ivar_getOffset((void*)object_getInstanceVariable((id)140215169790848,
“_number”, 0))</p>
<h1 id="cast-the-ptrdiff_t-to-an-int">Cast the ptrdiff_t to an int</h1>
<p>(int)(ptrdiff_t)ivar_getOffset((void*)object_getInstanceVariable((id)140215169790848,
“_number”, 0)) {% endhighlight %}</p>
<p>You can run each of these commands in lldb in a breakpoint and see what’s going
on:</p>
<p>{% highlight objc linenos=table %} (lldb) po (id)140215169790848
&lt;ViewController: 0x7f8663633380&gt;</p>
<p>(lldb) po object_getInstanceVariable((id)140215169790848, “_number”, 0)
0x0000000104ffc5a0</p>
<p>(lldb) po (void *)object_getInstanceVariable((id)140215169790848, “_number”, 0)
0x0000000104ffc5a0</p>
<p>(lldb) po ivar_getOffset((void *)object_getInstanceVariable((id)140215169790848,
“_number”, 0)) 0x0000000000000300</p>
<p>(lldb) po
(ptrdiff_t)ivar_getOffset((void*)object_getInstanceVariable((id)140215169790848,
“_number”, 0)) 768</p>
<p>(lldb) po
(int)(ptrdiff_t)ivar_getOffset((void*)object_getInstanceVariable((id)140215169790848,
“_number”, 0)) 768 {% endhighlight %}</p>
<p>Now we know that the offset for the instance variable we want to watch is 768
bytes from the address of its object.</p>
<p>— ### 3. Get the size in bytes of the instance variable</p>
<p>We need to konw the full size of the instance variable so we can watch that full
memory chunk for changes.</p>
<p>That is what this multi-line statement does.</p>
<p>{% highlight py linenos=table %} ivarSizeCommand = (‘unsigned int size = 0;’
‘char <em>typeEncoding = (char
</em>)ivar_getTypeEncoding((void<em>)class_getInstanceVariable((Class)object_getClass((id){}),
“{}”));’ ’(char </em>)NSGetSizeAndAlignment(typeEncoding, &amp;size, 0);’
‘size’).format(objectAddress, ivarName) ivarSize =
int(fb.evaluateExpression(ivarSizeCommand), 0) {% endhighlight %}</p>
<p>There a a few things going on here, so I’ll unpack them one statement at a time.</p>
<p>{% highlight objc linenos=table %}</p>
<h1 id="declare-a-var-to-hold-the-number-of-bytes-the-ivar-uses-unsigned-int-size-0">declare a var to hold the number of bytes the ivar uses unsigned int size = 0;</h1>
<h1 id="get-the-class-of-the-object-whose-instane-variable-we-want-to-watch">get the class of the object whose instane variable we want to watch</h1>
<p>object_getClass((id)140215169790848);</p>
<h1 id="cast-the-object-to-type-class-classobject_getclassid140215169790848">cast the object to type Class (Class)object_getClass((id)140215169790848);</h1>
<h1 id="get-a-reference-to-the-instance-variable-were-interested-in">get a reference to the instance variable we’re interested in</h1>
<p>class_getInstanceVariable((Class)object_getClass((id)140215169790848),
“_number”);</p>
<h1 id="cast-the-return-value-to-be-a-generic-pointer-void">cast the return value to be a generic pointer (void</h1>
<p>*)class_getInstanceVariable((Class)object_getClass((id)140215169790848),
“_number”);</p>
<h1 id="get-a-reference-to-the-type-encoding-of-the-instance-variable-were-interested">get a reference to the type encoding of the instance variable we’re interested</h1>
<p>in
ivar_getTypeEncoding((void*)class_getInstanceVariable((Class)object_getClass((id)140215169790848),
“_number”));</p>
<h1 id="cast-the-reference-to-be-a-c-string-char">cast the reference to be a C string (char</h1>
<p><em>)ivar_getTypeEncoding((void</em>)class_getInstanceVariable((Class)object_getClass((id)140215169790848),
“_number”));</p>
<h1 id="save-the-type-encoding-char-typeencoding-char">save the type encoding char *typeEncoding = (char</h1>
<p><em>)ivar_getTypeEncoding((void</em>)class_getInstanceVariable((Class)object_getClass((id)140215169790848),
“_number”));</p>
<h1 id="figure-out-how-many-bytes-typeencoding-requires-and-save-it-into-size-char">figure out how many bytes typeEncoding requires, and save it into &amp;size (char</h1>
<p>*)NSGetSizeAndAlignment(typeEncoding, &amp;size, 0);</p>
<h1 id="return-the-value-of-size-as-the-final-statement-of-the-multi-line-statement">return the value of size as the final statement of the multi-line statement;</h1>
<p>size</p>
<h1 id="the-end-result-after-string-substitution-unsigned-int-size-0-char">The end result after string substitution: unsigned int size = 0; char</h1>
<p><em>typeEncoding = (char
</em>)ivar_getTypeEncoding((void*)class_getInstanceVariable((Class)object_getClass((id)140215169790848),
“_number”)); (char *)NSGetSizeAndAlignment(typeEncoding, &amp;size, 0); size {%
endhighlight %}</p>
<p>We can execute all of the commands in a running lldb session with a breakpoint
set at a place where <code>self</code> resolves to the object we’re interested in.</p>
<p>{% highlight objc linenos=table %} (lldb) e unsigned int size = 0; (lldb) p
object_getClass((id)140215169790848); error: ‘object_getClass’ has unknown
return type; cast the call to its declared return type error: 1 errors parsing
expression (lldb) p (Class)object_getClass((id)140215169790848); (Class) $1 =
ViewController (lldb) p
class_getInstanceVariable((Class)object_getClass((id)140215169790848),
“_number”); error: ‘class_getInstanceVariable’ has unknown return type; cast the
call to its declared return type error: 1 errors parsing expression (lldb) p
(void *)class_getInstanceVariable((Class)object_getClass((id)140215169790848),
“_number”); (void <em>) $2 = 0x0000000104ffc5a0 (lldb) p
ivar_getTypeEncoding((void</em>)class_getInstanceVariable((Class)object_getClass((id)140215169790848),
“_number”)); error: ‘ivar_getTypeEncoding’ has unknown return type; cast the
call to its declared return type error: 1 errors parsing expression (lldb) p
(char
<em>)ivar_getTypeEncoding((void</em>)class_getInstanceVariable((Class)object_getClass((id)140215169790848),
“_number”)); (char <em>) $3 = 0x0000000104fdf656 “@"NSNumber"” (lldb) e unsigned
int size = 0; char </em>typeEncoding = (char
<em>)ivar_getTypeEncoding((void</em>)class_getInstanceVariable((Class)object_getClass((id)140215169790848),
“_number”)); (char *)NSGetSizeAndAlignment(typeEncoding, &amp;size, 0); size
(unsigned int) $4 = 8 {% endhighlight %}</p>
<p>And so after all that, we see that the <code>_number</code> takes up 8 bytes.</p>
<p>— ### Putting it all together</p>
<p>To recap, we needed three things to programmatically set the watchpoint for an
object’s instance variable. Those 3 things are:</p>
<div class="line-block">Description | Variable | Value | | — | — | —: | | 1. The address of the</div>
<p>object | <code>objectAddress</code> | 140215169790848 | | 2. The offset number of bytes
from the object’s Ivar | <code>ivarOffset</code> | 768 | | 3. The size in bytes of the
instance variable | <code>ivarSize</code> | 8 |</p>
<p>We’ve got all three of things now, so we should be able to call into the LLDB
Python API like so to set the watchpoint:</p>
<p>{% highlight py linenos=table %} error = lldb.SBError() watchpoint =
lldb.debugger.GetSelectedTarget().WatchAddress(objectAddress + ivarOffset,
ivarSize, False, True, error)</p>
<p>if error.Success(): print ‘Remember to delete the watchpoint using: watchpoint
delete {}’.format(watchpoint.GetID()) else: print ‘Could not create the
watchpoint: {}’.format(error.GetCString()) {% endhighlight %}</p>
<p>This is the current state, as shown in the git at the start of this post, so we
know something is wrong. Most likely we are calculating the one of three values
used in the <code>WatchAddress()</code> function incorrectly.</p>
<p>— ### Summary Objective-C runtime and helper functions used | Command |
Description | | — | :— | |
<a href="https://www.gnu.org/software/libc/manual/html_node/Important-Data-Types.html"><code>ptrdiff_t</code></a>
| memory size difference of points |
<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/#//apple_ref/c/func/ivar_getOffset"><code>ivar_getOffset</code></a>
| Returns the offset of an instance variable.
<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/#//apple_ref/c/func/object_getInstanceVariable"><code>object_getInstanceVariable</code></a>
| Obtains the value of an instance variable of a class instance.
<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/#//apple_ref/c/func/ivar_getTypeEncoding"><code>ivar_getTypeEncoding</code></a>
| Returns the type string of an instance variable. |
<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/#//apple_ref/c/func/class_getInstanceVariable"><code>class_getInstanceVariable</code></a>
| Returns the Ivar for a specified instance variable of a given class. |
<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/#//apple_ref/c/func/object_getClass"><code>object_getClass</code></a>
| Returns the class of an object. |
<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Functions/#//apple_ref/c/func/NSGetSizeAndAlignment"><code>NSGetSizeAndAlignment</code></a>
| Obtains the actual size and the aligned size of an encoded type. |
<a href="http://lldb.llvm.org/python_reference/lldb.SBTarget-class.html"><code>WatchAddress</code></a>
| Sets the watchpoint address based on starting address and size</p>
<hr />
<h2 id="chisel-helper-functions">Chisel Helper Functions</h2>
<p>The way to directly invoke an objective-c expression from a python interperter
in LLDB looks something like this:</p>
<p>{% highlight py linenos=table %} def
evaluateExpressionValueWithLanguage(expression, language, printErrors): frame =
lldb.debugger.GetSelectedTarget().GetProcess().GetSelectedThread().GetSelectedFrame()
expr_options = lldb.SBExpressionOptions() expr_options.SetLanguage(language) #
requires lldb r210874 (2014-06-13) / Xcode 6 value =
frame.EvaluateExpression(expression, expr_options) if printErrors and
value.GetError() is not None and str(value.GetError()) != ‘success’: print
value.GetError() return value {% endhighlight %}</p>
<p>Here we are digging down from the target to the process to the thread and
finally to a particular stack frame. In this stack frame context we can evaluate
different expressions. Instead of repeating this over and over, the chisel
library encapsulates these functions into a set of helper functions, which all
eventually call the chunk of code above.</p>
<p>In the code we reviewed above, we call 3 different version of these helper
functions: <code>evaluateIntegerExpression</code>, <code>evaluateExpression</code>, and
<code>evaluateObjectExpression</code>.</p>
<p>{% highlight py linenos=table %} def evaluateIntegerExpression(expression,
printErrors=True): output = evaluateExpression(‘(int)(’ + expression + ‘)’,
printErrors).replace(‘'’, ’‘) if output.startswith(’\x’): # Booleans may
display as  (Hex) output = output[2:] elif output.startswith(‘\’): # Or as
\0 (Dec) output = output[1:] return int(output, 16)</p>
<p>def evaluateExpression(expression, printErrors=True): print(expression) return
evaluateExpressionValue(expression, printErrors).GetValue()</p>
<p>def evaluateObjectExpression(expression, printErrors=True): return
evaluateExpression(‘(id)(’ + expression + ‘)’, printErrors) {% endhighlight %}</p>
<p>The bug is somewhere above. Can you find it? Clue: It’s in
<code>evaluateIntegerExpression</code>.</p>
<p>___ ## De(nouement)bug</p>
<p>This simple bug took hours to find, as the easiest bugs are the most subtle,
especially when you’re looking for hard bugs.</p>
<p>The problem is in <code>return int(output, 16)</code>. The python <code>int</code> functions’s
docstring is:</p>
<p>{% highlight py linenos=table %} In [1]: int? Docstring: int(x=0) -&gt; int or long
int(x, base=10) -&gt; int or long</p>
<p>Convert a number or string to an integer, or return 0 if no arguments are given.
If x is floating point, the conversion truncates towards zero. If x is outside
the integer range, the function returns a long instead.</p>
<p>If x is not a number or if base is given, then x must be a string or Unicode
object representing an integer literal in the given base. The literal can be
preceded by ‘+’ or ‘-’ and be surrounded by whitespace. The base defaults to 10.
Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string
as an integer literal.
&gt;&gt;&gt; int(‘0b100’, base=0)
4 Type: type {% endhighlight %}</p>
<p>You can pass an int or a an integer literal and define the base. In the above
code, we’re telling <code>int</code> that the base is base16. But that’s a problem, as we
will use a base16 value in our calculations with base10 values.</p>
<p>Recall from above that we used this command to determine the value of the <code>Ivar</code>
offset: {% highlight py linenos=table %}
(int)(ptrdiff_t)ivar_getOffset((void*)object_getInstanceVariable((id)140215169790848,
“_number”, 0)) {% endhighlight %}</p>
<p>I’ll run that command directly in LLDB, and then again after getting in a Python
interpreter from LLDB.</p>
<p>{% highlight py linenos=table %} (lldb) e
(int)(ptrdiff_t)ivar_getOffset((void*)object_getInstanceVariable((id)140215169790848,
“_number”, 0)) (int) $1 = 768 (lldb) script Python Interactive Interpreter. To
exit, type ‘quit()’, ‘exit()’ or Ctrl-D.
&gt;&gt;&gt; import fblldbbase
&gt;&gt;&gt; fblldbbase.evaluateIntegerExpression(’(int)(ptrdiff_t)ivar_getOffset((void*)object_getInstanceVariable((id)140215169790848,
&gt;&gt;&gt; “_number”, 0))’)
(int)((int)(ptrdiff_t)ivar_getOffset((void*)object_getInstanceVariable((id)140215169790848,
“_number”, 0))) 1896
&gt;&gt;&gt; fblldbbase.evaluateExpression(’(int)(ptrdiff_t)ivar_getOffset((void*)object_getInstanceVariable((id)140215169790848,
&gt;&gt;&gt; “_number”, 0))’)
(int)(ptrdiff_t)ivar_getOffset((void*)object_getInstanceVariable((id)140215169790848,
“_number”, 0)) ‘768’
&gt;&gt;&gt; int(‘768’, 16)
1896
&gt;&gt;&gt;
(lldb) {% endhighlight %}</p>
<p>Now the issue should be clear. We have the right objective-C expression to get
the size of the offset, but then we mess it up by telling python that the number
should be converted to base16 while it should stay in base10.</p>
<p>___ ## Resolution</p>
<p>Now that the bug is found after a lot of digging, the solution is trivial. You
can see the pull request <a href="https://github.com/facebook/chisel/pull/122">here</a>.</p>
<p>Comments and discussion on Hacker News
<a href="https://news.ycombinator.com/item?id=10447054">here</a>.</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
