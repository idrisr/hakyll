\documentclass[openany, 12pt]{article}
\input{preamble}

\begin{document}
\maketitle{}

\tcblistof[\section]{definition}{Definitions}

\section{Conceptual}
\begin{intuition}{Hakyll}{}
	It's all about taking a directory $D_1$ and its files, and then
	transforming them to another directory $D_2$ plus rules $R$ about how to
	route web requests so that they line up with the static web site in $D_2$.
\end{intuition}

\begin{definition}{Compiler}{}
	It defines the fundamental Compiler type and primitive Compilers as well as
	several variants on load, which allow you to bring together multiple
	resources to create a single output.
\end{definition}

\begin{definition}{Routes\index{route}}{}
	Specify where compiled items should go in the output site---used for
	determining the output file. For example, you probably want to write the
	processed contents of \bash{contact.markdown} to \bash{_site/contact.html}
	and not \bash{_site/contact.markdown}.
	\begin{haskell}{}
route :: FilePath -> FilePath -- pseudo code
\end{haskell}
\end{definition}

\begin{definition}{Rules\index{rule}}{}
	Each \hask{Rule} normally consists of three parts:

	\begin{enumerate}[label = {(\arabic*)}]
		\item Starting file $S$.  $s \in S$ are the files that will then make up the
		      static site. This includes all the normal web stuff like html, css,
		      svg, etc, but then also stuff that needs to be transformed like
		      markdown. $s\in S$ is identified via a pattern $P$.
		\item ending file $T$, which now in the domain of websites and routing,
		      so now it is called a route.
		\item file transformation, which is a function $f: S \rightarrow T$
		      which takes
	\end{enumerate}

	\begin{enumerate}[label = {(\arabic*)}]
		\item Source files (like Markdown files) to process (collected with
		      e.g.\@match or create).
		\item Compilation steps (like Markdown to HTML) to transform files'
		      content to some output content (steps are collected within Compiler
		      and executed with compile).
		\item Routing to determine if and where an output content will be
		      written out. For a static site this determines under which URL the
		      output content will be available (configured with route and
		      Routes).
	\end{enumerate}
\end{definition}

\begin{intuition}{Rules\index{rule}}{}
	A rule is basically a function that is waiting to be applied to an item.
	You introduce this rule ``function'' by combining a item and a compiler.
\end{intuition}

\begin{definition}{Store\index{store}}{}
	A store for storing and retreiving items.
\end{definition}

\begin{definition}{Page}{}
	Provides functions for rendering your pages using pandoc, with a varying
	degree of high-levelness.
\end{definition}

\begin{definition}{Template\index{template}}{}
	Templates are tools to convert items into a string. They are perfectly
	suited for laying out your site.
\end{definition}

\begin{definition}{Template.Context}{}
	You can’t do much with a Template if you don’t have a Context: this module
	provides some predefined Contexts and the tools to build your own.
\end{definition}

\begin{definition}{Main}{}
	The main hakyll function that runs the whole show. There is also a hakyllWith
	function which allows for a custom configuration.
\end{definition}

\begin{definition}{Item\index{item}}{}
	An item is a combination of some content and its Identifier. This way, we
	can still use the Identifier to access metadata.
\end{definition}

\begin{definition}{Identifier}{}
	A key data type to identify a compiled Item in the Store. Conceptually, it's a
	combination of a file path and a version name. The version is used only when a
	file is compiled within a rule using the version wrapper function (the same
	source file can be compiled into several items in the store, so the version
	exists to distinguish them). Use functions like fromFilePath, setVersion,
	getMatches to build an Identifier.
\end{definition}

\begin{definition} {Identifier.Pattern}{}
	Combinators for creating patterns, ie predicates that pick out a set of
	resources:
	\begin{multicols}{2}
		\begin{enumerate}[label = {(\arabic*)}]
			\item filesystem globs
			\item explicit lists
			\item regular expressions
			\item etc
		\end{enumerate}
	\end{multicols}
\end{definition}

\begin{definition}{match}{}
	Group the rules via \hask{match}. The filter on what match is done via
	\hask{Pattern}.
	\begin{haskell}{}
match  :: Pattern      -> Rules() -> Rules ()
create :: [Identifier] -> Rules() -> Rules ()
    \end{haskell}
\end{definition}

\begin{definition}{Configuration}{}
	Basically this tells you all the details about the filesystem options and
	network options for the site.

	\begin{haskell}{}
-- | Default configuration for a hakyll application
defaultConfiguration :: Configuration
defaultConfiguration = Configuration
    { destinationDirectory = "_site"
    , storeDirectory       = "_cache"
    , tmpDirectory         = "_cache/tmp"
    , providerDirectory    = "."
    , ignoreFile           = ignoreFile'
    , deployCommand        = "echo 'No deploy command specified' && exit 1"
    , deploySite           = system . deployCommand
    , inMemoryCache        = True
    , previewHost          = "127.0.0.1"
    , previewPort          = 8000
    }
  where
    ignoreFile' path
        | "."    `isPrefixOf` fileName = True
        | "#"    `isPrefixOf` fileName = True
        | "~"    `isSuffixOf` fileName = True
        | ".swp" `isSuffixOf` fileName = True
        | otherwise                    = False
      where
          fileName = takeFileName path
\end{haskell}
\end{definition}

\section{First Project}
Let's build a website that shows all my daily logs from the
\hask{~/roam-export} folder.

\printindex{}
\end{document}
